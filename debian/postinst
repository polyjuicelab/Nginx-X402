#!/bin/bash
set -e

# Build the module during package installation to match system nginx version
SRC_DIR="/usr/share/nginx-x402"
BUILD_DIR="/tmp/nginx-x402-build"
MODULE_DIR="/usr/lib/nginx/modules"

echo "Building nginx-x402 module for your system..."

# Detect nginx version - try multiple methods for accuracy
NGINX_VERSION=""
NGINX_VERSION_FULL=""

# Method 1: Use nginx -V to get detailed version info
if command -v nginx >/dev/null 2>&1; then
    NGINX_VERSION_FULL=$(nginx -v 2>&1)
    echo "Nginx version output: $NGINX_VERSION_FULL"
    NGINX_VERSION=$(echo "$NGINX_VERSION_FULL" | sed -n 's/.*nginx\/\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | head -1)
    
    # If still not found, try -V output
    if [ -z "$NGINX_VERSION" ]; then
        NGINX_VERSION=$(nginx -V 2>&1 | sed -n 's/.*nginx\/\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | head -1)
    fi
fi

# Method 2: Check dpkg if nginx command didn't work
if [ -z "$NGINX_VERSION" ] && dpkg -l nginx 2>/dev/null | grep -q "^ii"; then
    NGINX_VERSION=$(dpkg -l nginx | grep "^ii" | awk '{print $3}' | cut -d'-' -f1 | cut -d':' -f2 || echo "")
    echo "Detected nginx version from dpkg: $NGINX_VERSION"
fi

# Method 3: Try to read from nginx binary directly
if [ -z "$NGINX_VERSION" ] && [ -f "/usr/sbin/nginx" ]; then
    NGINX_VERSION=$(strings /usr/sbin/nginx 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | head -1 || echo "")
    echo "Detected nginx version from binary: $NGINX_VERSION"
fi

if [ -z "$NGINX_VERSION" ]; then
    echo "ERROR: Could not detect nginx version. Please ensure nginx is installed."
    echo "Tried methods: nginx -v, dpkg -l, reading binary"
    exit 1
fi

echo "Detected system nginx version: $NGINX_VERSION"

# Find or download matching nginx source
NGINX_SOURCE_DIR=""
if [ -d "/usr/src/nginx-$NGINX_VERSION" ] && [ -d "/usr/src/nginx-$NGINX_VERSION/objs" ]; then
    NGINX_SOURCE_DIR="/usr/src/nginx-$NGINX_VERSION"
elif [ -d "/usr/share/nginx-$NGINX_VERSION" ] && [ -d "/usr/share/nginx-$NGINX_VERSION/objs" ]; then
    NGINX_SOURCE_DIR="/usr/share/nginx-$NGINX_VERSION"
elif [ -d "/tmp/nginx-$NGINX_VERSION" ] && [ -d "/tmp/nginx-$NGINX_VERSION/objs" ]; then
    NGINX_SOURCE_DIR="/tmp/nginx-$NGINX_VERSION"
else
    echo "Downloading nginx-$NGINX_VERSION source..."
    mkdir -p /tmp
    if wget -q -O "/tmp/nginx-$NGINX_VERSION.tar.gz" "http://nginx.org/download/nginx-$NGINX_VERSION.tar.gz" 2>/dev/null; then
        (cd /tmp && tar -xzf "nginx-$NGINX_VERSION.tar.gz" && rm "nginx-$NGINX_VERSION.tar.gz")
        if [ -d "/tmp/nginx-$NGINX_VERSION" ]; then
            echo "Configuring nginx source..."
            # Get nginx configure arguments from system nginx
            NGINX_CONFIGURE_ARGS_SYSTEM=""
            if command -v nginx >/dev/null 2>&1; then
                NGINX_CONFIGURE_ARGS_SYSTEM=$(nginx -V 2>&1 | grep -oE 'configure arguments:.*' | sed 's/configure arguments://' || echo "")
                echo "System nginx configure args: $NGINX_CONFIGURE_ARGS_SYSTEM"
            fi
            
            # Configure nginx source with similar arguments
            if [ -n "$NGINX_CONFIGURE_ARGS_SYSTEM" ]; then
                # Remove problematic modules that require additional dependencies
                # Remove rewrite module (we don't need it)
                CONFIGURE_ARGS_CLEAN=$(echo "$NGINX_CONFIGURE_ARGS_SYSTEM" | sed 's/--with-http_rewrite_module//g')
                # Remove dynamic modules that may require additional libraries
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-http_xslt_module=dynamic//g')
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-http_perl_module=dynamic//g')
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-http_image_filter_module=dynamic//g')
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-http_geoip_module=dynamic//g')
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-mail=dynamic//g')
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-stream=dynamic//g')
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-stream_geoip_module=dynamic//g')
                # Remove --with-debug if present (may cause issues)
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/--with-debug//g')
                # Clean up multiple spaces
                CONFIGURE_ARGS_CLEAN=$(echo "$CONFIGURE_ARGS_CLEAN" | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
                # Add --without-http_rewrite_module if not already present
                if echo "$CONFIGURE_ARGS_CLEAN" | grep -qv -- "--without-http_rewrite_module"; then
                    CONFIGURE_ARGS_CLEAN="$CONFIGURE_ARGS_CLEAN --without-http_rewrite_module"
                fi
                
                echo "Running configure with system arguments..."
                echo "Cleaned configure args: $CONFIGURE_ARGS_CLEAN"
                # Use eval to properly handle quoted arguments
                (cd "/tmp/nginx-$NGINX_VERSION" && eval "./configure $CONFIGURE_ARGS_CLEAN" >/tmp/nginx-configure.log 2>&1 || {
                    echo "Configure with system args failed, checking log..."
                    if [ -f /tmp/nginx-configure.log ]; then
                        echo "Last 50 lines of configure log:"
                        tail -50 /tmp/nginx-configure.log || true
                    fi
                    echo "Trying minimal configuration with -fPIC..."
                    ./configure --without-http_rewrite_module --with-cc-opt="-fPIC" >/tmp/nginx-configure.log 2>&1 || {
                        echo "Minimal configure also failed"
                        if [ -f /tmp/nginx-configure.log ]; then
                            tail -50 /tmp/nginx-configure.log || true
                        fi
                        exit 1
                    }
                })
                
                # Verify configure actually succeeded by checking for key files
                if [ ! -f "/tmp/nginx-$NGINX_VERSION/objs/ngx_modules.c" ]; then
                    echo "ERROR: Configure appeared to succeed but ngx_modules.c not found"
                    if [ -f /tmp/nginx-configure.log ]; then
                        echo "Full configure log:"
                        cat /tmp/nginx-configure.log
                    fi
                    exit 1
                fi
                
                # Show what was actually configured
                echo "Configure completed. Checking configured options..."
                if [ -f "/tmp/nginx-$NGINX_VERSION/objs/ngx_auto_config.h" ]; then
                    echo "Key configuration values:"
                    grep -E "NGINX_VER|NGX_PTR_SIZE|NGX_SIG_ATOMIC_T" "/tmp/nginx-$NGINX_VERSION/objs/ngx_auto_config.h" 2>/dev/null | head -10 || true
                fi
            else
                # Fallback to minimal configuration
                echo "No system configure args found, using minimal configuration..."
                (cd "/tmp/nginx-$NGINX_VERSION" && ./configure --without-http_rewrite_module --with-cc-opt="-fPIC" >/tmp/nginx-configure.log 2>&1 || {
                    echo "Minimal configure failed"
                    if [ -f /tmp/nginx-configure.log ]; then
                        tail -30 /tmp/nginx-configure.log || true
                    fi
                    exit 1
                })
            fi
            
            if [ -d "/tmp/nginx-$NGINX_VERSION/objs" ]; then
                NGINX_SOURCE_DIR="/tmp/nginx-$NGINX_VERSION"
                echo "Nginx source configured successfully"
            else
                echo "WARNING: Nginx configure may have failed. Check /tmp/nginx-configure.log"
                if [ -f "/tmp/nginx-configure.log" ]; then
                    echo "Last 30 lines of configure log:"
                    tail -30 /tmp/nginx-configure.log || true
                fi
            fi
        fi
    fi
fi

if [ -z "$NGINX_SOURCE_DIR" ] || [ ! -d "$NGINX_SOURCE_DIR/objs" ]; then
    echo "ERROR: Failed to find or configure nginx source for version $NGINX_VERSION"
    exit 1
fi

echo "Using nginx source: $NGINX_SOURCE_DIR"

# Verify nginx source version matches system version
if [ -f "$NGINX_SOURCE_DIR/src/core/nginx.h" ]; then
    NGINX_SOURCE_VERSION=$(grep -E 'NGINX_VERSION' "$NGINX_SOURCE_DIR/src/core/nginx.h" | head -1 | sed -n 's/.*"\(.*\)".*/\1/p' || echo "")
    if [ -n "$NGINX_SOURCE_VERSION" ]; then
        echo "Nginx source version: $NGINX_SOURCE_VERSION"
        if [ "$NGINX_SOURCE_VERSION" != "$NGINX_VERSION" ]; then
            echo "WARNING: Nginx source version ($NGINX_SOURCE_VERSION) does not match system version ($NGINX_VERSION)"
            echo "This may cause binary compatibility issues"
        fi
    fi
fi

# Set up build environment
export NGINX_SOURCE_DIR="$NGINX_SOURCE_DIR"
export CARGO_FEATURES="--no-default-features"
export NGX_CONFIGURE_ARGS="--without-http_rewrite_module"

# Verify NGINX_SOURCE_DIR is set correctly
echo "Build environment:"
echo "  NGINX_SOURCE_DIR=$NGINX_SOURCE_DIR"
echo "  CARGO_FEATURES=$CARGO_FEATURES"
echo "  NGX_CONFIGURE_ARGS=$NGX_CONFIGURE_ARGS"

# Verify nginx source has been configured correctly
if [ ! -f "$NGINX_SOURCE_DIR/objs/ngx_modules.c" ]; then
    echo "ERROR: Nginx source appears to be not configured properly"
    echo "Missing: $NGINX_SOURCE_DIR/objs/ngx_modules.c"
    exit 1
fi

# Check nginx version in objs/ngx_auto_config.h
if [ -f "$NGINX_SOURCE_DIR/objs/ngx_auto_config.h" ]; then
    echo "Nginx auto config found, checking version compatibility..."
    NGINX_BUILD_VERSION=$(grep -E 'NGINX_VER' "$NGINX_SOURCE_DIR/objs/ngx_auto_config.h" 2>/dev/null | head -1 | sed -n 's/.*"\(.*\)".*/\1/p' || echo "")
    if [ -n "$NGINX_BUILD_VERSION" ]; then
        echo "Nginx build version: $NGINX_BUILD_VERSION"
        if [ "$NGINX_BUILD_VERSION" != "$NGINX_VERSION" ]; then
            echo "WARNING: Build version ($NGINX_BUILD_VERSION) != System version ($NGINX_VERSION)"
        fi
    fi
fi

# Set libclang path
if [ -z "$LIBCLANG_PATH" ]; then
    if [ -d /usr/lib64/llvm/lib ]; then
        export LIBCLANG_PATH=/usr/lib64/llvm/lib
    elif [ -d /usr/lib/llvm/lib ]; then
        export LIBCLANG_PATH=/usr/lib/llvm/lib
    elif ls -d /usr/lib64/llvm*/lib >/dev/null 2>&1; then
        export LIBCLANG_PATH=$(ls -d /usr/lib64/llvm*/lib 2>/dev/null | head -1)
    elif ls -d /usr/lib/llvm-*/lib >/dev/null 2>&1; then
        export LIBCLANG_PATH=$(ls -d /usr/lib/llvm-*/lib 2>/dev/null | head -1)
    fi
fi

# Verify Rust toolchain is available
if ! command -v cargo >/dev/null 2>&1; then
    echo "ERROR: cargo not found. Please install cargo."
    exit 1
fi

if ! command -v rustc >/dev/null 2>&1; then
    echo "ERROR: rustc not found. Please install rustc."
    exit 1
fi

# Check Rust version - need at least 1.80.0 for edition2024 support
RUST_VERSION=$(rustc --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
RUST_MAJOR=$(echo "$RUST_VERSION" | cut -d'.' -f1)
RUST_MINOR=$(echo "$RUST_VERSION" | cut -d'.' -f2)

if [ "$RUST_MAJOR" -lt 1 ] || ([ "$RUST_MAJOR" -eq 1 ] && [ "$RUST_MINOR" -lt 80 ]); then
    echo "WARNING: System Rust version $RUST_VERSION is too old. Need at least 1.80.0"
    echo "Attempting to install rustup and use newer Rust version..."
    
    # Try to install rustup if not available
    if ! command -v rustup >/dev/null 2>&1; then
        echo "Installing rustup..."
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable || {
            echo "ERROR: Failed to install rustup"
            echo "Please install rustup manually or update your system Rust package to at least 1.80.0"
            exit 1
        }
        # Source rustup environment
        export PATH="$HOME/.cargo/bin:$PATH"
        source "$HOME/.cargo/env" 2>/dev/null || true
    fi
    
    # Use rustup to install/use stable toolchain
    if command -v rustup >/dev/null 2>&1; then
        echo "Installing stable Rust toolchain via rustup..."
        rustup toolchain install stable --profile minimal || {
            echo "ERROR: Failed to install Rust toolchain via rustup"
            exit 1
        }
        rustup default stable || {
            echo "ERROR: Failed to set default Rust toolchain"
            exit 1
        }
        export PATH="$HOME/.cargo/bin:$PATH"
        
        # Verify new version
        RUST_VERSION=$(rustc --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        RUST_MAJOR=$(echo "$RUST_VERSION" | cut -d'.' -f1)
        RUST_MINOR=$(echo "$RUST_VERSION" | cut -d'.' -f2)
        
        if [ "$RUST_MAJOR" -lt 1 ] || ([ "$RUST_MAJOR" -eq 1 ] && [ "$RUST_MINOR" -lt 80 ]); then
            echo "ERROR: Installed Rust version $RUST_VERSION is still too old"
            exit 1
        fi
        echo "Using Rust version from rustup: $RUST_VERSION"
    else
        echo "ERROR: rustup not available and system Rust version is too old"
        exit 1
    fi
else
    echo "Using Rust version: $RUST_VERSION"
fi

# Build the module
echo "Building module..."
mkdir -p "$BUILD_DIR"
cp -r "$SRC_DIR"/* "$BUILD_DIR/"
# Copy README.md if it exists in source directory (needed for doc generation)
if [ -f "$SRC_DIR/README.md" ]; then
    cp "$SRC_DIR/README.md" "$BUILD_DIR/"
fi
cd "$BUILD_DIR"

# Ensure Cargo.toml exists
if [ ! -f "Cargo.toml" ]; then
    echo "ERROR: Cargo.toml not found in source directory"
    rm -rf "$BUILD_DIR"
    exit 1
fi

# Remove Cargo.lock if it exists (let cargo regenerate it)
# This avoids lock file version compatibility issues
rm -f Cargo.lock

# Generate fresh Cargo.lock
echo "Generating Cargo.lock..."
cargo generate-lockfile || {
    echo "WARNING: Failed to generate Cargo.lock, continuing anyway..."
}

# Build with verbose output to see what's happening
echo "Building module with cargo..."
echo "Command: cargo build --release $CARGO_FEATURES"
echo "NGINX_SOURCE_DIR=$NGINX_SOURCE_DIR"

cargo build --release $CARGO_FEATURES 2>&1 | tee /tmp/cargo-build.log || {
    echo "ERROR: Failed to build module"
    echo "Build logs:"
    tail -100 /tmp/cargo-build.log
    rm -rf "$BUILD_DIR"
    exit 1
}

echo "Build completed successfully"

# Find and copy the built module
MODULE_FILE=$(find target -name "libnginx_x402.so" -type f | head -1)
if [ -z "$MODULE_FILE" ]; then
    echo "ERROR: Built module not found"
    rm -rf "$BUILD_DIR"
    exit 1
fi

# Ensure module directory exists
mkdir -p "$MODULE_DIR"
if [ ! -d "$MODULE_DIR" ]; then
    echo "ERROR: Failed to create module directory: $MODULE_DIR"
    rm -rf "$BUILD_DIR"
    exit 1
fi

cp "$MODULE_FILE" "$MODULE_DIR/libnginx_x402.so"
chmod 644 "$MODULE_DIR/libnginx_x402.so"

# Clean up build directory
rm -rf "$BUILD_DIR"

echo "Module built and installed successfully!"
echo "Module location: $MODULE_DIR/libnginx_x402.so"

exit 0

