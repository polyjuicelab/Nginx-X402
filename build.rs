#![deny(warnings)]

use std::env;
use std::fs;
use std::io;
use std::path::PathBuf;

/// Default module signature used as fallback when nginx source is not available.
/// This matches a typical nginx configuration: 64-bit pointers, 32-bit atomic, 64-bit time.
const DEFAULT_SIGNATURE: &str = "8,4,8,0010111111010111001111111111100110";

/// Default feature flags used when they cannot be extracted from nginx source.
const DEFAULT_FEATURE_FLAGS: &str = "0010111111010111001111111111100110";

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    // Extract nginx module signature from source
    let signature = extract_nginx_module_signature();

    // Generate a Rust file with the signature
    if let Err(e) = generate_signature_file(&signature) {
        eprintln!("cargo:warning=Failed to generate signature file: {}", e);
        eprintln!(
            "cargo:warning=Using default signature: {}",
            DEFAULT_SIGNATURE
        );
        // Continue with default signature - don't fail the build
    }

    // Configure linker flags for dynamic nginx modules
    configure_linker_flags();
}

/// Generate the module signature Rust file.
fn generate_signature_file(signature: &str) -> io::Result<()> {
    let out_dir = env::var("OUT_DIR")
        .map_err(|e| io::Error::new(io::ErrorKind::NotFound, format!("OUT_DIR not set: {}", e)))?;

    let signature_file = PathBuf::from(&out_dir).join("module_signature.rs");

    let signature_code = format!(
        r#"// Auto-generated module signature
// This file is generated by build.rs from nginx source configuration
// DO NOT EDIT MANUALLY - changes will be overwritten
pub const MODULE_SIGNATURE: &[u8] = b"{}\0";
"#,
        signature
    );

    fs::write(&signature_file, signature_code)?;
    println!("cargo:rerun-if-changed={}", signature_file.display());

    Ok(())
}

/// Configure linker flags for dynamic nginx modules.
///
/// Dynamic nginx modules need to allow undefined symbols because nginx symbols
/// will be resolved at runtime when the module is loaded by nginx.
fn configure_linker_flags() {
    // macOS requires explicit flags to allow undefined symbols
    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-link-arg=-undefined");
        println!("cargo:rustc-link-arg=dynamic_lookup");
    }

    // Linux shared libraries (.so) allow undefined symbols by default
    // The symbols will be resolved when nginx loads the module at runtime
}

/// Extract nginx module signature from source files.
///
/// The signature format is: "{NGX_PTR_SIZE},{NGX_SIG_ATOMIC_T_SIZE},{NGX_TIME_T_SIZE},{feature_flags}"
///
/// This function tries multiple methods in order of reliability:
/// 1. Extract from objs/ngx_modules.c (most reliable, contains exact signature)
/// 2. Build from objs/ngx_auto_config.h (fallback, constructs from defines)
/// 3. Use default signature (final fallback)
fn extract_nginx_module_signature() -> String {
    let nginx_source_dir = match env::var("NGINX_SOURCE_DIR") {
        Ok(dir) => PathBuf::from(dir),
        Err(_) => {
            return DEFAULT_SIGNATURE.to_string();
        }
    };

    let modules_path = nginx_source_dir.join("objs/ngx_modules.c");
    let auto_config_path = nginx_source_dir.join("objs/ngx_auto_config.h");

    // Try to extract signature from ngx_modules.c first (most reliable)
    if let Ok(modules_content) = fs::read_to_string(&modules_path) {
        if let Some(signature) = extract_signature_from_modules_c(&modules_content) {
            return signature;
        }
    }

    // Fallback: Build signature from ngx_auto_config.h
    if let Ok(config_content) = fs::read_to_string(&auto_config_path) {
        if let Some(signature) = build_signature_from_config_h(&config_content) {
            return signature;
        }
    }

    // Final fallback: use default signature
    DEFAULT_SIGNATURE.to_string()
}

/// Extract signature from ngx_modules.c file.
///
/// Looks for: `char ngx_module_signature[] = "8,4,8,0010111111010111001111111111100110";`
/// Handles both single-line and multi-line string definitions.
fn extract_signature_from_modules_c(content: &str) -> Option<String> {
    // Try simple single-line extraction first
    for line in content.lines() {
        if let Some(sig) = extract_quoted_string_from_line(line, "ngx_module_signature") {
            if sig.contains(',') {
                return Some(sig);
            }
        }
    }

    // Fallback: try multi-line extraction
    extract_multiline_signature(content)
}

/// Extract signature from a line containing the signature definition.
fn extract_quoted_string_from_line(line: &str, marker: &str) -> Option<String> {
    if !line.contains(marker) || !line.contains('"') {
        return None;
    }

    let start = line.find('"')?;
    let end = line.rfind('"')?;

    if end > start {
        Some(line[start + 1..end].to_string())
    } else {
        None
    }
}

/// Extract multi-line signature definition.
///
/// Handles cases where the signature string spans multiple lines:
/// ```c
/// char ngx_module_signature[] = "8,4,8,"
///     "0010111111010111001111111111100110";
/// ```
fn extract_multiline_signature(content: &str) -> Option<String> {
    let mut in_signature = false;
    let mut signature_parts = Vec::new();

    for line in content.lines() {
        if line.contains("ngx_module_signature") {
            in_signature = true;
        }

        if in_signature {
            // Extract quoted string parts
            let mut start = 0;
            while let Some(quote_start) = line[start..].find('"') {
                let quote_start = start + quote_start;
                if let Some(quote_end) = line[quote_start + 1..].find('"') {
                    let quote_end = quote_start + 1 + quote_end;
                    signature_parts.push(line[quote_start + 1..quote_end].to_string());
                    start = quote_end + 1;
                } else {
                    // String continues on next line
                    signature_parts.push(line[quote_start + 1..].to_string());
                    break;
                }
            }

            // Check if we've completed the signature (line ends with semicolon)
            if line.trim().ends_with(';') {
                let signature = signature_parts.join("");
                if !signature.is_empty() {
                    return Some(signature);
                }
                in_signature = false;
                signature_parts.clear();
            }
        }
    }

    None
}

/// Build signature from ngx_auto_config.h defines.
///
/// Constructs signature from:
/// - NGX_PTR_SIZE
/// - NGX_SIG_ATOMIC_T_SIZE
/// - NGX_TIME_T_SIZE
/// - NGX_MODULE_SIGNATURE_1..N (feature flags)
fn build_signature_from_config_h(content: &str) -> Option<String> {
    let ptr_size = extract_define_value(content, "NGX_PTR_SIZE").unwrap_or(8);
    let sig_atomic_size = extract_define_value(content, "NGX_SIG_ATOMIC_T_SIZE").unwrap_or(4);
    let time_size = extract_define_value(content, "NGX_TIME_T_SIZE").unwrap_or(8);

    // Extract feature flags from NGX_MODULE_SIGNATURE_1..N
    let feature_flags = extract_feature_flags(content);

    Some(format!(
        "{},{},{},{}",
        ptr_size, sig_atomic_size, time_size, feature_flags
    ))
}

/// Extract feature flags from NGX_MODULE_SIGNATURE_1..N defines.
fn extract_feature_flags(content: &str) -> String {
    let mut feature_flags = String::new();
    let mut sig_num = 1;

    loop {
        let sig_name = format!("NGX_MODULE_SIGNATURE_{}", sig_num);
        match extract_define_string(content, &sig_name) {
            Some(value) => {
                feature_flags.push_str(&value);
                sig_num += 1;
            }
            None => break,
        }
    }

    if feature_flags.is_empty() {
        DEFAULT_FEATURE_FLAGS.to_string()
    } else {
        feature_flags
    }
}

/// Extract a numeric value from a #define directive.
///
/// Example: `#define NGX_PTR_SIZE 8` -> Some(8)
fn extract_define_value(content: &str, name: &str) -> Option<u32> {
    let define_pattern = format!("#define {}", name);

    for line in content.lines() {
        if line.contains(&define_pattern) {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                if let Ok(value) = parts[2].parse::<u32>() {
                    return Some(value);
                }
            }
        }
    }

    None
}

/// Extract a string or numeric value from a #define directive.
///
/// Handles both quoted strings and numeric values:
/// - `#define NGX_MODULE_SIGNATURE_1 "0010"` -> Some("0010")
/// - `#define NGX_MODULE_SIGNATURE_1 0010` -> Some("0010")
fn extract_define_string(content: &str, name: &str) -> Option<String> {
    let define_pattern = format!("#define {}", name);

    for line in content.lines() {
        if line.contains(&define_pattern) {
            // Try to extract quoted string first
            if let Some(start) = line.find('"') {
                if let Some(end) = line.rfind('"') {
                    if end > start {
                        return Some(line[start + 1..end].to_string());
                    }
                }
            }

            // Fallback: extract numeric value
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 {
                return Some(parts[2].to_string());
            }
        }
    }

    None
}
